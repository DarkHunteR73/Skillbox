#include <fstream>
#include <iostream>

int main() {
  std::string path;
  std::cout << "Path to file: ";
  std::cin >> path;

  std::ifstream file;
  file.open(path, std::ios::binary);

  if (!file.is_open()) {
    std::cout << "File not found..." << std::endl;
  } else {
    bool correctExtension = false, correctHeader = false;

    if (path.substr(path.size() - 4) == ".png" ||
        path.substr(path.size() - 4) == ".PNG") {
      correctExtension = true;
    }

    char headNum;
    char buffer[4];

    file >> headNum;
    file.read(buffer, sizeof(buffer) - 1);
    buffer[sizeof(buffer) - 1] = '\0';

    if (headNum == -119 && static_cast<std::string>(buffer) == "PNG") {
      correctHeader = true;
    }

    std::cout << (correctExtension && correctHeader ? "File is PNG"
                                                    : "File is not PNG")
              << std::endl;
  }
}

/*
Задание 4. Разработка детектора PNG-файла
Что нужно сделать

Разработайте программу, которая получает на вход, в стандартный ввод, путь к
файлу. На выходе программа должна определить, является ли данный файл
PNG-изображением. Данная процедура не просто должна смотреть на расширение
файла, но и произвести минимальный анализ его внутренностей, в бинарном режиме.

Внутренности валидного бинарного файла начинаются со специального 8-байтового
заголовка. Нас будут интересовать первые четыре байта. Первый байт всегда имеет
значение −119 (число со знаком минус), а следующие — это просто символы ‘P’,
‘N’, ‘G’, расположенные друг за другом. Обратите внимание, что все они в верхнем
регистре.

По результатам проверки пути и внутренностей требуется сообщить пользователю о
результате проверки в стандартный вывод.


Советы и рекомендации

Чтобы определить расширение файла, используйте функцию substr, которая получает
офсет и длину подстроки и возвращает её.


Что оценивается

Для произвольных путей файлов, введённых пользователем, требуется выдавать
корректный результат — являются ли они PNG-файлами или нет.
*/